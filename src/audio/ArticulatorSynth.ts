import { VowelSpace } from './VowelSpace';

export interface ArticulatoryState {
    lipClosure: number;           // 0 (Open) to 1 (Closed)
    tongueHeight: number;         // 0 (Low) to 1 (High)
    tongueBackness: number;       // 0 (Front) to 1 (Back)
    tongueTipPosition: number;    // 0 (Low) to 1 (Alveolar Ridge)
    isVoiced: boolean;
    plosiveTrigger: boolean;
    energyTrigger: boolean;       // New utterance trigger
}

export interface AcousticParams {
    f1: number;
    f2: number;
    f3: number;
    oralGain: number;
    nasalGain: number;
    fricativeGain: number;
    fricativeFreq: number;
    voicingMix: number; // 0=Noise only, 1=Voicing only
}

export class ArticulatorSynth {

    static mapStateToAcoustic(state: ArticulatoryState): AcousticParams {
        // 1. Formants from Tongue Position
        // We use the existing VowelSpace but map our articulatory parameters to it
        // VowelSpace expects: x (Backness), y (Openness/InvHeight)
        // Our state.tongueHeight: 1=High (Close), 0=Low (Open)
        // So VowelSpace y = 1 - state.tongueHeight

        const vowelFormants = VowelSpace.getFormants(state.tongueBackness, 1 - state.tongueHeight);

        // 2. Oral Gain (Lip Closure)
        // Closed lips = 0 oral gain
        const oralGain = Math.max(0, 1 - state.lipClosure);

        // 3. Nasal Gain
        // Nasal path is open when velum is lowered. 
        // In this simple model, we can say:
        // If lips are closed (m, n), sound MUST go through nose.
        // So Nasal Gain increases as Oral Gain decreases?
        // Or we can have a specific "Nasal" gesture.
        // Let's make it automatic for now: High Lip Closure -> High Nasal Gain
        // But only if we want /m/. If we want /b/, we need velum closed.
        // Let's add a small amount of nasality by default for resonance, 
        // and boost it when lips are closed to simulate /m/.
        const nasalGain = 0.2 + (state.lipClosure * 0.8);

        // 4. Fricatives
        // Generated by constrictions.
        // - Labiodental (f/v): Lip Closure ~ 0.5
        // - Alveolar (s/z): Tongue Tip High
        // - Postalveolar (sh): Tongue Tip High + Back

        let fricativeGain = 0;
        let fricativeFreq = 5000; // Default /s/

        // Logic for Fricative Detection
        if (state.tongueTipPosition > 0.8) {
            // Alveolar /s/ or /z/
            fricativeGain = (state.tongueTipPosition - 0.8) * 5; // Scale 0..1
            fricativeFreq = 6000;

            // If Tongue is also Back, it's /sh/ (lower freq)
            if (state.tongueBackness > 0.6) {
                fricativeFreq = 3000;
            }
        } else if (state.lipClosure > 0.3 && state.lipClosure < 0.8) {
            // Labiodental /f/ or /v/
            // "Biting lip" is hard to track, so we use partial closure
            fricativeGain = Math.min(state.lipClosure, 1 - state.lipClosure) * 2;
            fricativeFreq = 8000; // Higher freq noise
        }

        // Cap fricative gain
        fricativeGain = Math.min(fricativeGain, 1.0);

        // 5. Voicing Mix
        // If isVoiced is true, we want mostly Glottal Source.
        // If false (Whisper), we want Noise Source.
        // But Fricatives need Noise regardless of voicing.
        // We'll handle this in the AudioEngine, but here we return the "Voice" amount.
        const voicingMix = state.isVoiced ? 1.0 : 0.0;

        return {
            f1: vowelFormants.f1,
            f2: vowelFormants.f2,
            f3: vowelFormants.f3,
            oralGain,
            nasalGain,
            fricativeGain,
            fricativeFreq,
            voicingMix
        };
    }
}
